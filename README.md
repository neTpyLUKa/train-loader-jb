

./gradlew run

./gradlew test

Код решения: https://github.com/neTpyLUKa/train-loader-jb/blob/master/src/main/kotlin/App.kt

Тесты: https://github.com/neTpyLUKa/train-loader-jb/blob/master/src/test/kotlin/test.kt

# Описание алгоритма

Буду решать с помощью динамического программирования

Предполагаю, что в один и тот же момент времни возможно закончить разгружать вагон и начать новый.

Сначала опишу наивное решение:

В порядке возрастания времени будем хранить лучший результат, и пересчитывать оптимальное значение через предыдущеие результаты

dp[train.timeEnd] = max(dp[train,timeStart] + train.payment, best_result)

Где dp - массив, dp[train.timeEnd] - наибольший возможный заработок, если закончить разгружать вагоны не позже времени train.timeEnd

Попробуем улучшить результат с помощью вагона train, то есть рассмотрим наибольший возможный заработок, если разгружать этот поезд (заканчивая во время train.timeEnd), тогда заработок составит dp[train.timeStart] + train.payment, то есть выплата за текущий поезд и наибольший результат до времени train.timeStart.

Теперь, чтобы восстановить ответ (список номеров поездов), будем дополнительно хранить номер последнего разгруженного поезда в массиве dp. Тогда посмотрим на dp[train.timeStart].trainId, это номер предыдущего поезда, и так далее

В этом решении плохо то, что для каждого момента времени нужно хранить результат, не совсем понятно сколько интересующих моментов времени. Для описанной задачи логично предположить, что достаточно работать только с минутами, но не с секундами, но тогда решение совсем тривиальное. Также оно тяжело масштабируется на несколько дней (например, подсчёт прибыли за весь месяц).

Я в своём решении работаю с секундами, предполагая, что поезд может прибыть в любую из них.

Далее опишу моё решение:

Будем хранить не все моменты времени, а только те, которые совпадают со временем прибытия и окончания разгрузки поезда.

Для это воспользуюсь TreeMap.

Функция чтения со стандартного ввода сейчас читает минуты, поэтому лучше запускать функцию solve из тестов.

# train-loader-jb

Далее описано условие задачи с добавленными мною ограничениями на входные данные

Представьте себя грузчиком, работающим на товарной станции. В течении дня на станцию прибывают поезда и их надо немедленно разгружать.

Для каждого поезда известно:

номер поезда
время прибытия,
время, которое у вас займёт разгрузка,
сумма, которую вам заплатят за разгрузку этого поезда.
Начав разгрузку поезда, вы должны ее закончить и не можете разгружать два поезда одновременно.

Необязательно браться за разгрузку всех поездов. На станции есть другие грузчики.

Ваша задача написать алгоритм, который по этим исходным данным максимизирует ваш заработок.

Очень желательны тесты. Было бы прекрасно также получить несколько слов о реализованном алгоритме, его источнике, достоинствах, ограничениях, вылщедтчислительной сложности и тп.

# Входные данные:

Сначала идёт число n - количество поездов, неотрицательное число, помещающееся в int

Далее n строк, каждая из которых имеет вид (trainId, timeStart, duration, payment), где

trainId - номер поезда, неотрицательное число, помещающееся в int

timeStart - время прибытия поезда, это строка, в которой записано время согласно форматной строке из аргументов запуска (см. примеры запуска)

duration - время, которое займёт разгрузка, записано аналогично timeStart

payment - объём награды за разгрузку поезда, положительное число помещающееся в int
